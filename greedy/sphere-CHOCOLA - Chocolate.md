# [CHOCOLA - Chocolate](https://www.spoj.com/problems/CHOCOLA/)

![](https://badgen.net/badge/Level/Medium/yellow)

We are given a bar of chocolate composed of m*n square pieces. One should break the chocolate into single squares. Parts of the chocolate may be broken along the vertical and horizontal lines as indicated by the broken lines in the picture.

A single break of a part of the chocolate along a chosen vertical or horizontal line divides that part into two smaller ones. Each break of a part of the chocolate is charged a cost expressed by a positive integer. This cost does not depend on the size of the part that is being broken but only depends on the line the break goes along. Let us denote the costs of breaking along consecutive vertical lines with x1, x2, ..., xm-1 and along horizontal lines with y1, y2, ..., yn-1.

The cost of breaking the whole bar into single squares is the sum of the successive breaks. One should compute the minimal cost of breaking the whole chocolate into single squares.

For example, if we break the chocolate presented in the picture first along the horizontal lines, and next each obtained part along vertical lines then the cost of that breaking will be y1+y2+y3+4*(x1+x2+x3+x4+x5).

Input
One integer in the first line, stating the number of test cases, followed by a blank line. There will be not more than 20 tests.

For each test case, at the first line there are two positive integers m and n separated by a single space, 2 <= m,n <= 1000. In the successive m-1 lines there are numbers x1, x2, ..., xm-1, one per line, 1 <= xi <= 1000. In the successive n-1 lines there are numbers y1, y2, ..., yn-1, one per line, 1 <= yi <= 1000.

The test cases will be separated by a single blank line.
### Approach Used :

-   Sorting in Descending Order: Sorting the vertical and horizontal costs in descending order ensures that we always prioritize the most expensive cuts, which is key to minimizing the total cost.
-   Greedy Strategy: The algorithm iteratively picks the more expensive cut (either vertical or horizontal) and updates the total cost accordingly. The number of pieces generated by each type of cut is tracked to properly scale the cost of subsequent cuts.
-   Handling Remaining Cuts: After processing the initial sorted lists, any remaining cuts are handled in the order of their remaining costs, ensuring all necessary breaks are made.

### Code (C++)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int minCostToBreakChocolate(vector<int>& verticalCosts, vector<int>& horizontalCosts) {
    // Sort both cost arrays in descending order
    sort(verticalCosts.rbegin(), verticalCosts.rend());
    sort(horizontalCosts.rbegin(), horizontalCosts.rend());

    int verticalCuts = 1; // Initially, we have one vertical piece
    int horizontalCuts = 1; // Initially, we have one horizontal piece
    int totalCost = 0;

    int i = 0, j = 0;
    int m = verticalCosts.size();
    int n = horizontalCosts.size();

    // Use a greedy approach to decide which cut to make
    while (i < m && j < n) {
        if (verticalCosts[i] > horizontalCosts[j]) {
            totalCost += verticalCosts[i] * horizontalCuts;
            verticalCuts++;
            i++;
        } else {
            totalCost += horizontalCosts[j] * verticalCuts;
            horizontalCuts++;
            j++;
        }
    }

    // If there are remaining vertical cuts
    while (i < m) {
        totalCost += verticalCosts[i] * horizontalCuts;
        i++;
    }

    // If there are remaining horizontal cuts
    while (j < n) {
        totalCost += horizontalCosts[j] * verticalCuts;
        j++;
    }

    return totalCost;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int m, n;
        cin >> m >> n;

        vector<int> verticalCosts(m - 1);
        vector<int> horizontalCosts(n - 1);

        for (int i = 0; i < m - 1; i++) {
            cin >> verticalCosts[i];
        }

        for (int i = 0; i < n - 1; i++) {
            cin >> horizontalCosts[i];
        }

        // Output the minimum cost for the current test case
        cout << minCostToBreakChocolate(verticalCosts, horizontalCosts) << endl;

        // Skip the blank line between test cases
        if (t > 0) {
            string blankLine;
            getline(cin, blankLine);
            if (blankLine.empty()) {
                getline(cin, blankLine);
            }
        }
    }
    return 0;
}

```

### Time Complexity:
- **O((m+n)log(m+n)):** due to the sorting of the cost arrays.

### Space Complexity:
- **O(m+n):** for storing the cost arrays.

### Connect With Me : 

<a href="https://www.linkedin.com/in/shivam-ray-b4306524a/" target="_blank"><img src="https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white" alt="LinkedIn"></a>
<a href="https://x.com/rai_shivam11/" target="_blank"><img src="https://img.shields.io/badge/Twitter-1DA1F2?style=for-the-badge&logo=twitter&logoColor=white" alt="X (formerly Twitter)">
</a>
<a href="https://leetcode.com/u/shrunited0702/" target="_blank"><img src="https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06" alt="leetcode">
</a>